//Cliente
#include <unistd.h>  
/* includes para los SOCKETS */
#include <netdb.h> 
#include <netinet/in.h>   
#include <sys/socket.h>
#include <arpa/inet.h>
/*Para errores*/
#include <errn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DATO_MAXIMO 10000  //definimos el dato maximo
#define PORT 8080  //Definimos el puerto 8080 que es la alternativa para usar el http
#define Sock struct sockaddr

//funcion para pedir numeros
void pedir_Numeros (char numeros[]){
	printf ("Ingresa el nÃºmero: ");
	scanf ("%d", numeros);
}


int main(int argc, char **argv)
{

	if(argc<2){
		printf("<HOST > <PUERTO>\n");
    	return 1;
  	}

	//DEFINIMOS LAS VARIABLES
	    //escuchar, file descriptor
	int sockfd, connfd;

	//ESTRUCTURA PARA EL SERVIDOR Y EL CLIENTE
	//en esta estructura se define el formato de la direccion 
	//familia, puerto y la direccionn IPv4
	struct sockaddr_in servaddr, cliente_1;

	//CREACION DEL SOCKET 
	                //dominio,   tipo, protocolo
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	//si hay un error, devuelve -1
	if (sockfd == -1)
	{
		printf(stderr, "ERROR FALLA LA CREACION DEL SOCKET\n");
			exit (0)
	}
	else

		printf ("-->SOCKET CREADO EXITOSAMENTE \n");

	//crea la esctrucura address format
	memset(&servaddr,0,sizeof(servaddr));

	//asignar IP, Puerto y direccion IPv4
	servaddr.sin_family        = AF_INET;
	servaddr.sin_addr.s_addr   = htonl(INADDR_ANY);;
	servaddr.sin_port          = htons(atoi(argv[1]));  //este valor ordena los bits
	
    //CONECTAMOS LOS SOCKETS-- CLIENTE && SERVIDOR
	if (connect(sockfd, (Socket*)&servaddr, sizeof(servaddr)) != 0) {
		printf("ERROR LA CONEXION FALLA\n");
		return -1;
	}
	else
		printf("-->CONEXION CON SERVIDOR EXITOSO\n");

	fD_funcion(sockfd);  //LLAMADA A LA FUNCION DEL FILE DESCRIPTOR
	close(sockfd); //TERMINAMOS EL SOCKET
}

void fD_funcion(int sockfd)
{
 char numero1[DATO_MAXIMO];
 char numero2[DATO_MAXIMO];
 char resultado[DATO_MAXIMO];
 char buff[DATO_MAXIMO]; //definimos buffer para recepcion

 //borramos el area de memoria dada con cero byte
    bzero(buff, sizeof(buff));
	bzero(numero1, sizeof(numero1));
	bzero(numero2,sizeof(numero2));
	bzero(resultado,sizeof(resultado));

	//mandamos a llamar a la funcion para pedir los numeros
	pedir_Numeros(numero1);
	//funcion write: el cliente envÃ­a datos al servidor
    write(sockfd, numero1, sizeof(numero1));
    pedir_Numeros(numero2);
    write(sockfd, numero2, sizeof(numero2));

    bzero(buff, sizeof(buff));
	bzero(resultado,sizeof(resultado));

    //funcion read: lee lo que el servidor responde 
    //lee el resultado de la suma
    read(sockfd, resultado, sizeof(resultado)); 
	printf("\n ****RESULTADO= %s  (Longitud %d digitos)\n", resultado,strlen(resultado));
}
----------------------------------------------------------------------------------------------
//Servidor
#include <unistd.h>  
/* includes para los SOCKETS */
#include <netdb.h> 
#include <netinet/in.h>   
#include <sys/socket.h>
#include <arpa/inet.h>
/*Para errores*/
#include <errn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DATO_MAXIMO 10000  //definimos el dato maximo
#define PORT 8080  //Definimos el puerto 8080 que es la alternativa para usar el http
#define Sock struct sockaddr

/*Definimos las variables*/
char numero1[DATO_MAXIMO];
char numero2[DATO_MAXIMO];
char resultado[DATO_MAXIMO];
char buff_rx[DATO_MAXIMO]; //definimos buffer para reccepcion


/*Creamos el mÃ©todo para la SUMA que vamos a ocupar*/
void SUMAR_NUMEROS(char numero1[], char numero2[], char resultado[]){
/*Definimos variables que nos ayudaran*/
	int longitud_MAX, n1, n2, i, j, k;
/*Auxuliares para almacenar lo calculado posteriormente*/
    int aux_N1[n1], aux_N2[n2], aux_LONG[longitud_MAX];

/*CALCULAMOSLA LONGITUD DE AMBAS CADENAS
strlen --> Devuelve la longitud de una cadena*/
n1 = strlen (numero1);
n2 = strlen (numero2);

	//REALIZAMOS LA COMPARACIÃ“N DE LA LONGITUD DE AMBOS NÃšMEROS
    //PARA DETERMINAR LA MÃXIMA LONGITUD
    if(n1>n2)
    	longitud_MAX=n1;
    else
    	longitud_MAX=n2;

/*CONVERTIMOS LOS NÃšMEROS DE CARACTER A ENTERO*/
/*Usamos el truco de restar del dÃ­gito el nÃºmero '0'*/
for ( i=0; i<n1; i++){
	aux_N1[i] =n1[i]-'0';
}
for ( j=0; j<n2; j++){
	aux_N2[j] =n2[j]-'0';
}

j = n2 - 1;
k = longitud_MAX-1;

for (i=n1-1; i>0 && j>0; i--)
{
aux_LONG[k] = aux_N1[i]+ aux_N2[j];
j--;
k--;
}
//reducimos los contadores
for (;i>=0; --i, --j){
	aux_LONG = aux_N1[j];
} 
for (;i>=0; --j, --k){
	aux_LONG = aux_N2[k];
} 

for (k = longitud_MAX-1; k>0; k--)
{
	if (aux_LONG[k]>9)
	{
		aux_LONG[k]= aux_LONG[k]%10;
		//aux_LONG[k-1]= aux_LONG[k-1]+1;
		aux_LONG[k]+=1;
	}
}
i=0;
for(k=0; k<longitud_MAX; k++)
{
	if(aux_LONG[k]>9)
	{
     resultado[i]=(aux_LONG[k]-10)+'0';
	}
	else
		resultado[i]=aux_LONG[k]+'0';
	i++;
}

int main(int argc, char const *argv[])
{
	//DEFINIMOS LAS VARIABLES
	    //escuchar, descriptor, longitud 
	int sockfd, connfd, long1;
	//ESTRUCTURA PARA EL SERVIDOR Y EL CLIENTE
	//en esta estructura se define el formato de la direccion
	//familia, puerto y la direcciÃ³n IPv4
	struct sockaddr_in servaddr, cliente_1;
 
//CREACION DEL SOCKET 
	                //dominio,   tipo, protocolo
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	//si hay un error, devuelve -1
	if (sockfd == -1)
	{
		printf(stderr, "ERROR FALLA LA CREACION DEL SOCKET\n");
			exit (0)
	}
	else

		printf ("-->SOCKET CREADO EXITOSAMENTE \n");

	//crea la esctrucura saddreess format
	memset(&servaddr,0,sizeof(servaddr));

	//asignar IP, Puerto y direccion IPv4
	servaddr.sin_family        = AF_INET;
	servaddr.sin_addr.s_addr   = htonl(INADDR_ANY);;
	servaddr.sin_port          = htons(atoi(argv[1]));  //este valor ordena los bits
	
	//ASIGNAMOS DIRECCION IP Y PUERTO
	        //file descriptor   puntero a la estrucutra, el tamaño de la esctructura
	        // (SI EL No. ES MAYOR A 0, ASIGNÃ“ CORRECTAMENTE)
	if ((bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr))) !=0)
	{
		printf(stderr, "ERROR FALTA  ASIGNAR DIRECCION IP Y PUERTO %s\n");
	    return -1;
	}
	else 
	{
		printf("--> IP Y PUERTO ASIGNADO CORRECTAMENTE\n");
	}

	//llamada al sistema linsten
	             //5 corresponde al backlog No. maximo de conexiones pendientes
	if ((listen(sockfd, 5)) !=0)
	{
		printf("ERROR LA LLAMADA AL SISTEMA FALLA.\n");
		exit(0);
	}
	else
		printf("-->LLAMADA AL SISTEMA EXITOSA\n");

	//cargamos en la variable longitud el tamaño de la estructura para el address formato del cliente
	long1 = sizeof(cliente_1);

	//Aceptamos a los clientes
	connfd = accept(sockfd, (Sock*)&cliente_1, &long);
	if (connfd < 0) {
		printf("ERROR EL SERVIDOR NO PUDO ACEPTAR AL CLIENTE \n");
		exit(0);
	}
	else
		printf("-->CLIENTE ACEPTADO CORRECTAMENTE\n");

	printf("-------------CONECTADO AL SERVIDOR------------------\n");

	fD_funcion(connfd); //mandamos a llamar a la funcion del file descriptor
	close(sockfd);  //CERRAR SOCKET
}
